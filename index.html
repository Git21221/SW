<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Software Engineering</title>
  </head>

  <body>
    <strong>Definition: </strong> It is a systematic, disciplined, cost
    effectiveness techniue for Software developent. Engineering appoach to
    develop a Software. <br />

    <strong>Characteristics: </strong>
    <ul>
      <li>Correctness</li>
      <li>Usability</li>
      <li>Reliability</li>
      <li>Efficiency</li>
      <li>Maintainability</li>
      <li>Portability</li>
      <li>Scalability</li>
      <li>Security</li>
      <li>Modularity</li>
      <li>Reusuability</li>
      <li>Testibility</li>  
    </ul>

    <strong>SDLC:</strong>
    planning -> analysis (SRS) -> design -> code -> testing -> deploy ->
    planning <br />

    <strong>Waterfall model:</strong>
    feasibility study -> requirement analysis and specifications -> design ->
    coding and unit testing -> System testing and integration -> maintainance
    <br />
    <strong>Advantages: </strong>
    i) Base model ii) simple and easy iii) small projects <br>
    <strong>Disadvantages: </strong>
    i)No feedback ii) No experiment iii) no paralleism iv) High risk v) 60%
    efforts in maintainance. <br />
    <strong>Iterative waterfall model: </strong>
    sae as waterfall but after maintainance feedback will inclde in all part
    except study. <br />
    <strong>V model in SDLC: </strong> <br />
    <ol>
      <li>Known as verification and validation model</li>
      <li>Extension of waterfall model</li>
      <li>testing is associated with every phase.</li>
      <li>
        verification phase (Reqirement analysis, system design, architecture
        design, module design)
      </li>
      <li>
        Validation phase (unit testing, integration, system, acceptance testing)
      </li>
    </ol>
    <strong>Advantages: </strong>
    <ol>
      <li>time saving</li>
      <li>Good understanding of project in the beginning</li>
      <li>every component must be feasible</li>
      <li>progress can be tracked easily</li>
    </ol>
    <strong>Disadvantages: </strong>
    <ol>
      <li>no feedback so less scope of changes</li>
      <li>Risk analysis not done</li>
      <li>Not good for big or object oriented project.</li>
    </ol>
    <strong>Prototype model: </strong>
    <ol>
      <li>Csutomer not clear with idea can understand a prototype</li>
      <li>Throwaway model</li>
      <li>Good for technical and reqiurement risks.</li>
      <li>Increase in cost of development.</li>
    </ol>
    <strong>Incremental model: </strong>
    <ol>
      <li>module by module.</li>
      <li>Customer interaction maximum.</li>
      <li>large projects</li>
      <li>early release product demand</li>
      <li>fleible to demand</li>
    </ol>
    <strong>Evolutionary odl</strong>
    <ol>
      <li>
        Evolutionary model is a cobination of Iterative and Incremental model of
        SDLC.
      </li>
      <li>
        Incremental model first implement a few basic features and deliver to
        the Csutomer and then build the next part and do the sae and continue.
      </li>
      <li>Iterative odl ain Advantages is its feedback in every process</li>
      <li>
        Also known as "design a little, bild a little, test a little, deploy a
        little"
      </li>
    </ol>
    <strong>Advantages: </strong>
    <ol>
      <li>Cstoer reuirement are clearly specified</li>
      <li>Risk analysis is better</li>
      <li>It suupports changing environent</li>
      <li>Initial operating tie is less</li>
    </ol>
    <strong>Disadvantages: </strong>
    <ol>
      <li>Not siutable for saller projects</li>
      <li>cost</li>
      <li>highly skilled resorces reuired</li>
    </ol>
    <strong>Spiral model:</strong>
    <ol>
      <li>objecive determination and identfy alternative solutions.</li>
      <li>identify and resolve risks</li>
      <li>develop next version of product.</li>
      <li>Review and plan for next phase.</li>
      <li>radis of spiral = cost</li>
      <li>anglar dimension = progress</li>
    </ol>
    <strong>Agile technology: </strong>
    Big pojects breaks into smaller part. <br />
    <strong>Advantages: </strong>
    <ol>
      <li>Freqent delivery</li>
      <li>Face to face communication</li>
      <li>changes</li>
      <li>time</li>
    </ol>
    <strong>Disadvantages</strong>
    <ol>
      <li>less documentation</li>
      <li>maintainance problem</li>
    </ol>
    <strong>SCRUM model: </strong>
    <ol>
      <li>One of the most popular agile methodology</li>
      <li>Scrum is lightweight, Iterative, and incremental framework.</li>
      <li>
        Scrum breaks down the development phases into stages or cycles called
        "sprints"
      </li>
      <li>
        The developent time for each sprint is maximized and dedicated, thereby
        managing only one sprint at a time.
      </li>
      <li>Scrum Team has scrum master and product owner with cons</li>
      <li>
        Keywords: Backlog, Sprint, daily Scrum, scrum master, product owner
      </li>
    </ol>
    <strong>Advantages: </strong>
    <ol>
      <li>Freedom & adaption</li>
      <li>high-quality, low-risk product.</li>
      <li>Reduce the development time up to 40%.</li>
      <li>Scrum customer satisfaction is very important</li>
      <li>reviweing the current sprint before moving to new one.</li>
    </ol>
    <strong>Disadvantages: </strong>
    <ol>
      <li>More efficient for small team size.</li>
      <li>No changes in the sprint.</li>
    </ol>
    <strong>Software requirement</strong>
    <ol>
      <li>
        It is the description of features and functionalities of the target
        system.
      </li>
      <li>It is the description of what the system should do.</li>
      <li>
        requirement Engineering(RE) refers to the process of defining,
        documentation, maintaining reqiurement in the Engineering design
        process.
      </li>
      <li>
        it is a four step process, which includes
        <ul>
          <li>feasibility study</li>
          <li>Reqirement gathering</li>
          <li>Software reqiurement specifications</li>
          <li>Software reqiurement validation</li>
        </ul>
      </li>
    </ol>
    <strong>Tool support for requirement Engg</strong>
    <ul>
      <li>Observation Reports (user Observation)</li>
      <li>Question interviews, surveys and polls</li>
      <li>use case</li>
      <li>user stories</li>
      <li>Requirement workshops</li>
      <li>Mind mapping</li>
      <li>Role-playing</li>
      <li>Prototyping</li>
    </ul>
    <strong>Functional and non functional reqiurements</strong>
    <ul>
      <li>
        Reqirements which are related to functional/Working aspect pf Software
        fall into this category.
      </li>
      <li>
        Non-functional reqiurements are exprected characteristics of target
        software. (security, storage, configuration, performance, cost,
        interoperability, flexibility, disaster recovery)
      </li>
    </ul>
    <strong>SRS (Software Reqirement Specifications)</strong>
    <ul>
      <li>SRS is a description of a software system to be developed.</li>
      <li>
        it lays out functional and non-functional requirement to be develop.
      </li>
      <li>
        It may include a set of use cases that describe user interactions that
        the software must provide to the user for perfect interaction.
      </li>
    </ul>
    <strong>SRS structure</strong>
    <ol>
      <li>Introduction</li>
      <ol>
        <li>Purpose</li>
        <li>Intended Audience</li>
        <li>Scope</li>
        <li>Definitions</li>
        <li>References</li>
      </ol>
      <li>Overall description</li>
      <ol>
        <li>User Interfaces</li>
        <li>Systemm Interfaces</li>
        <li>Constraints, assumptions and dependencies</li>
        <li>User characteristics</li>
      </ol>
      <li>system features and reqiurement</li>
      <ol>
        <li>Functional Reqirements</li>
        <li>use cases</li>
        <li>External Interface requirement</li>
        <li>Logical database reqiurement</li>
        <li>Non-functional reqiurement</li>
      </ol>
      <li>Deliver for approval</li>
    </ol>
    <strong>User requirement</strong>
    <ul>
      <li>Easy and simple to operate</li>
      <li>Quick response</li>
      <li>effectively handling operational errors</li>
      <li>customer support</li>
    </ul>
    <strong>user requirement specifications</strong>
    <ul>
      <li>It defines what the user expects the software to be able to do.</li>
      <li>It is a contractual aggrement.</li>
    </ul>
    <strong>Software design</strong>
    <ul>
      <li>Interface design</li>
      <li>Architectural design</li>
      <li>Details design</li>
    </ul>
    <strong>Modularity</strong>
     Breaks into smaller module and handle them.
     <strong>Coupling: </strong> one module is dependent on another. low Coupling is best.
     <ul>
      <strong>Coupling</strong>
      <li>data</li>
      <li>stamp</li>
      <li>control</li>
      <li>external</li>
      <li>common</li>
      <li>content</li>
     </ul>
     <strong>Cohesion: </strong> it's a functional strength between module. High cohesion is best. <br>
    <strong>DFD (Data Flow Diagram)</strong>
    <ul>
      <li>
        A graphical tool useful for communicating with managers and other
        personel.
      </li>
      <li>useful for analyzing existing as well as proposed systems.</li>
      <li>
        Focus on the movement of data between external entities and processes,
        and between processes and data store.
      </li>
      <li>A relatively simple technique to learn and use.</li>
    </ul>
    <strong>Why DFD?</strong>
    <ul>
      <li>What data a system process</li>
      <li>What transformations are performed</li>
      <li>What data are stored</li>
      <li>What results are produced</li>
      <li>
        Graphical nature makes it a good communications tool between -> i) user
        and analyst ii) Analyst and system designer
      </li>
    </ul>
    <strong>**DFD elements</strong>
    <ul>
      <li>Source/Sinks (external links)</li>
      <li>Data flows</li>
      <li>Processes</li>
      <li>Data Stores</li>
    </ul>
    <strong>External links</strong>
    <ul>
        <li>A rectangle represents an external entity</li>
        <li>They either supply or receive data</li>
        <li>They do not process data</li>
        <strong>Source:</strong>Entity that supples data to the system.
        <strong>Sink:</strong>Entity that receives data from the system.
    </ul>
    <strong>**Rules of data flow</strong>
    <ul>
        <li><strong>Data can flow from</strong></li>
        <ul>
            <li>External entity to process</li>
            <li>Process to external entity</li>
            <li>process to store and back</li>
            <li>process to process</li>
        </ul>
        <li><strong>Data cannot flow from</strong></li>
        <ul>
            <li>External entity to external entity</li>
            <li>External entity to store</li>
            <li>Store to external entity</li>
            <li>Store to store</li>
        </ul>
    </ul>
    <strong>Logocal and physical DFD</strong>
    <ul>
      <li>DFDs considered so far are called logical DFDs</li>
      <li>A physical DFD is similar to a document flow diagram</li>
      <li>It specifies who does the operations specified by the logical DFDs.</li>
      <li>Physical DFD may depict physical movemments of goods.</li>
      <li>Physical DFDs can be drawn during fact gathering phase of a life cycle.</li>
    </ul>
    <strong>Software design approaches</strong>
    <ul>
      <li><strong>Function orient design</strong></li>
      <ul>
        <li>System is designed from a functional viewpoint.</li>
        <li>Top-down decomposition</li>
        <li>Divide & conquer approach</li>
        <li>DFD is used</li>
      </ul>
      <li><strong>Object Orient Design</strong></li>
      <ul>
        <li>System is viewed as a collection of objects</li>
        <li>Bottom-up approach</li>
        <li>UML is used.</li>
      </ul>
    </ul>
    <strong>SPM (software project manager)</strong>
    <ul>
      <li>Software project management is a art and science of planning and leading software projects.</li>
      <li>Main goal is to enable a group of developers to work effectively towards successful completion of project.</li>
      <li>Project manager is an administrative leader of the team.</li>
      <li>Various factors make this job very complex (complexity, uniqueness, possibility of multiple solutions)</li>
    </ul>
    <strong>Black box/validation and white box/verification testing</strong> <br>
    <strong>Software quality factor</strong>
    can be divided into two categories: i) first, ii) second category
    <strong>Charcateristics of quality assurance</strong> <br>
    <ul>
      <li>Standards</li>
      <li>Quality Attributes</li>
      <li>Continuous Improvement</li>
      <li>Metrics</li>
      <li>Training</li>
      <li>Documentation</li>
    </ul>
    <strong>Classic model of software quality factor</strong>
    i) Product operation(Correctness, Reliability, Usability), ii) Product revision(Maintainability, flexibility), iii) product transition(Portability, Reusuability)
    <strong>Capability Maturity Model</strong>
    CMM is a strategy to improve the software process and generate quality software. The term "maturity" relates to the degree of formality and optimization of process. <br>
    5 levels are there
    <ul>
      <li>lvl1(initial)</li>
      <li>lvl2(managed)</li>
      <li>lvl3(defined)</li>
      <li>lvl4(managed quality)</li>
      <li>lvl5(optimization)</li>
    </ul>
    <strong>Estimation model: </strong>Here we estimate about two things time and cost of developemnt.
    <br>Has four types: 
    <ol>
      <li>Post</li>
      <li>Base</li>
      <li>Decomposition</li>
      <li>Empirical</li>
    </ol>
    <strong>Post Estimation: </strong>In case of fiendly party or known technology we do not estimate either time or cost. <br>
    <strong>Base Estimation: </strong> we predict the cost and time of the entire project based on the experience. <br>
    <strong>Decomposition: </strong> used in large project where decomposition of the problem into smaller problem.
    <br>Two types: i) Direct extimation(white box), ii) Indirect Estimation(Black box).
    <strong>Direct Estimation</strong>
    <ul>
      <li>Effort = Size / Productivity</li>
      <li>cost = Effort * Pay</li>
      <li>Team Size = Effort / Duration</li>
    </ul>
    <strong>Indirect estimation</strong>
  </body>
</html>